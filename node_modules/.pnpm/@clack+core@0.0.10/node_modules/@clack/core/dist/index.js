// src/prompts/prompt.ts
import { WriteStream } from "node:tty";
import { stdin, stdout } from "node:process";
import readline from "node:readline";
import { cursor, erase } from "sisteransi";
function diffLines(a, b) {
  if (a === b)
    return;
  const aLines = a.split("\n");
  const bLines = b.split("\n");
  const diff = [];
  for (let i = 0; i < Math.max(aLines.length, bLines.length); i++) {
    if (aLines[i] !== bLines[i])
      diff.push(i);
  }
  return diff;
}
var cancel = Symbol("clack:cancel");
function isCancel(value) {
  return value === cancel;
}
function setRawMode(input, value) {
  if (input.isTTY)
    input.setRawMode(value);
}
var keys = /* @__PURE__ */ new Set(["up", "down", "left", "right"]);
var Prompt = class {
  constructor({ render, input = stdin, output = stdout, initialValue, ...opts }, trackValue = true) {
    this._track = false;
    this._cursor = 0;
    this.state = "initial";
    this.error = "";
    this.subscribers = /* @__PURE__ */ new Map();
    this._prevFrame = "";
    this.opts = opts;
    this.onKeypress = this.onKeypress.bind(this);
    this.close = this.close.bind(this);
    this.render = this.render.bind(this);
    this._render = render.bind(this);
    this._track = trackValue;
    this.input = input;
    this.output = output;
  }
  prompt() {
    const sink = new WriteStream(0);
    sink._write = (chunk, encoding, done) => {
      if (this._track) {
        this.value = this.rl.line.replace(/\t/g, "");
        this._cursor = this.rl.cursor;
        this.emit("value", this.value);
      }
      done();
    };
    this.input.pipe(sink);
    this.rl = readline.createInterface({
      input: this.input,
      output: sink,
      tabSize: 2,
      prompt: "",
      escapeCodeTimeout: 50
    });
    readline.emitKeypressEvents(this.input, this.rl);
    this.rl.prompt();
    this.input.on("keypress", this.onKeypress);
    setRawMode(this.input, true);
    this.render();
    return new Promise((resolve, reject) => {
      this.once("submit", () => {
        resolve(this.value);
      });
      this.once("cancel", () => {
        this.output.write(cursor.show);
        resolve(cancel);
      });
    });
  }
  on(event, cb) {
    const arr = this.subscribers.get(event) ?? [];
    arr.push({ cb });
    this.subscribers.set(event, arr);
  }
  once(event, cb) {
    const arr = this.subscribers.get(event) ?? [];
    arr.push({ cb, once: true });
    this.subscribers.set(event, arr);
  }
  emit(event, ...data) {
    const cbs = this.subscribers.get(event) ?? [];
    const cleanup = [];
    for (const subscriber of cbs) {
      subscriber.cb(...data);
      if (subscriber.once) {
        cleanup.push(() => cbs.splice(cbs.indexOf(subscriber), 1));
      }
    }
    for (const cb of cleanup) {
      cb();
    }
  }
  unsubscribe() {
    this.subscribers.clear();
  }
  onKeypress(char, key) {
    if (this.state === "error") {
      this.state = "active";
    }
    if ((key == null ? void 0 : key.name) && keys.has(key.name)) {
      this.emit("cursor", key.name);
    }
    if (char && (char.toLowerCase() === "y" || char.toLowerCase() === "n")) {
      this.emit("confirm", char.toLowerCase() === "y");
    }
    if ((key == null ? void 0 : key.name) === "return") {
      if (this.opts.validate) {
        const problem = this.opts.validate(this.value);
        if (problem) {
          this.error = problem;
          this.state = "error";
        }
      }
      if (this.state !== "error") {
        this.state = "submit";
      }
    }
    if (char === "") {
      this.state = "cancel";
    }
    if (this.state === "submit" || this.state === "cancel") {
      this.emit("finalize");
    }
    this.render();
    if (this.state === "submit" || this.state === "cancel") {
      this.close();
    }
  }
  close() {
    this.input.removeListener("keypress", this.onKeypress);
    this.output.write("\n");
    setRawMode(this.input, false);
    this.rl.close();
    this.emit(`${this.state}`, this.value);
    this.unsubscribe();
  }
  // TODO: handle wrapping
  restoreCursor() {
    const lines = this._prevFrame.split("\n").length - 1;
    this.output.write(cursor.move(-999, lines * -1));
  }
  render() {
    const frame = this._render(this) ?? "";
    if (frame === this._prevFrame)
      return;
    if (this.state === "initial") {
      this.output.write(cursor.hide);
    } else {
      const diff = diffLines(this._prevFrame, frame);
      this.restoreCursor();
      if (diff && (diff == null ? void 0 : diff.length) === 1) {
        const diffLine = diff[0];
        this.output.write(cursor.move(0, diffLine));
        this.output.write(erase.lines(1));
        const lines = frame.split("\n");
        this.output.write(lines[diffLine]);
        this._prevFrame = frame;
        this.output.write(cursor.move(0, lines.length - diffLine - 1));
        return;
      } else if (diff && (diff == null ? void 0 : diff.length) > 1) {
        const diffLine = diff[0];
        this.output.write(cursor.move(0, diffLine));
        this.output.write(erase.down());
        const lines = frame.split("\n");
        const newLines = lines.slice(diffLine);
        this.output.write(newLines.join("\n"));
        this._prevFrame = frame;
        return;
      }
      this.output.write(erase.down());
    }
    this.output.write(frame);
    if (this.state === "initial") {
      this.state = "active";
    }
    this._prevFrame = frame;
  }
};

// src/prompts/text.ts
import color from "picocolors";
var TextPrompt = class extends Prompt {
  constructor(opts) {
    super(opts);
    this.valueWithCursor = "";
    this.on("finalize", () => {
      this.valueWithCursor = this.value;
    });
    this.on("value", () => {
      if (this.cursor >= this.value.length) {
        this.valueWithCursor = `${this.value}${color.inverse(color.hidden("_"))}`;
      } else {
        const s1 = this.value.slice(0, this.cursor);
        const s2 = this.value.slice(this.cursor);
        this.valueWithCursor = `${s1}${color.inverse(s2[0])}${s2.slice(1)}`;
      }
    });
  }
  get cursor() {
    return this._cursor;
  }
};

// src/prompts/password.ts
import color2 from "picocolors";
var PasswordPrompt = class extends Prompt {
  constructor({ mask, ...opts }) {
    super(opts);
    this.valueWithCursor = "";
    this._mask = "\u2022";
    this._mask = mask ?? "\u2022";
    this.on("finalize", () => {
      this.valueWithCursor = this.masked;
    });
    this.on("value", () => {
      if (this.cursor >= this.value.length) {
        this.valueWithCursor = `${this.masked}${color2.inverse(color2.hidden("_"))}`;
      } else {
        const s1 = this.masked.slice(0, this.cursor);
        const s2 = this.masked.slice(this.cursor);
        this.valueWithCursor = `${s1}${color2.inverse(s2[0])}${s2.slice(1)}`;
      }
    });
  }
  get cursor() {
    return this._cursor;
  }
  get masked() {
    return this.value.split("").map(() => this._mask).join("");
  }
};

// src/prompts/select.ts
var SelectPrompt = class extends Prompt {
  constructor(opts) {
    super(opts, false);
    this.cursor = 0;
    this.options = opts.options;
    this.cursor = this.options.findIndex(({ value }) => value === opts.initialValue);
    if (this.cursor === -1)
      this.cursor = 0;
    this.on("value", () => {
      this.value = this._value.value;
    });
    this.on("cursor", (key) => {
      switch (key) {
        case "left":
        case "up":
          return this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
        case "down":
        case "right":
          return this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
      }
    });
  }
  get _value() {
    return this.options[this.cursor];
  }
};

// src/prompts/confirm.ts
var ConfirmPrompt = class extends Prompt {
  get cursor() {
    return this.value ? 0 : 1;
  }
  get _value() {
    return this.cursor === 0;
  }
  constructor(opts) {
    super(opts, false);
    this.value = opts.initialValue ? true : false;
    this.on("value", () => {
      this.value = this._value;
    });
    this.on("confirm", (confirm) => {
      this.value = confirm;
      this.state = "submit";
      this.close();
    });
    this.on("cursor", () => {
      this.value = !this.value;
    });
  }
};

// src/utils.ts
import * as readline2 from "node:readline";
import { stdin as stdin2, stdout as stdout2 } from "node:process";
import { cursor as cursor2 } from "sisteransi";
function block({ input = stdin2, output = stdout2, overwrite = true, hideCursor = true } = {}) {
  const rl = readline2.createInterface({
    input,
    output,
    prompt: "",
    tabSize: 1
  });
  readline2.emitKeypressEvents(input, rl);
  if (input.isTTY)
    input.setRawMode(true);
  const clear = (data, { name }) => {
    const str = String(data);
    if (str === "") {
      process.exit(0);
    }
    if (!overwrite)
      return;
    let dx = name === "return" ? 0 : -1;
    let dy = name === "return" ? -1 : 0;
    readline2.moveCursor(output, dx, dy, () => {
      readline2.clearLine(output, 1, () => {
        input.once("keypress", clear);
      });
    });
  };
  if (hideCursor)
    process.stdout.write(cursor2.hide);
  input.once("keypress", clear);
  return () => {
    input.off("keypress", clear);
    if (hideCursor)
      process.stdout.write(cursor2.show);
    rl.close();
  };
}
export {
  ConfirmPrompt,
  PasswordPrompt,
  Prompt,
  SelectPrompt,
  TextPrompt,
  block,
  isCancel
};
